/************************************************************************
	カントリ識別処理モジュール

	Copyright (C) JE3HHT 1993-2000.
************************************************************************/
//---------------------------------------------------------------------------
#include <vcl.h>
#pragma hdrstop

#include "ComLib.h"
#include "Country.h"
#include "string.h"
#include "stdlib.h"

CCountry	Cty;
/*#$%
========================================================
	文字列から指定の文字をクリップする
--------------------------------------------------------
	s : 文字列のポインタ
--------------------------------------------------------
--------------------------------------------------------
========================================================
*/
static char *_delchr(char *s, char c)
{
	char	*p;

	for( p = s; *p; p++ ){
		if( *p == c ){
			strcpy(p, p+1);
			p--;
		}
	}
	return(s);
}

/*#$%
======================================================
	異なる文字列のポインタを返す
------------------------------------------------------
	n : 範囲数の格納位置のポインタ
	t : プリフィックスのポインタ
	p : プリフィックスのポインタ
------------------------------------------------------
------------------------------------------------------
======================================================
*/
static LPSTR lcmpp(int *n, LPSTR s, LPSTR p)
{
	LPSTR	t;

	for( t = s; *p && *t; p++, t++ ){
		if( *p != *t ){
			*n = (*p - *t) + 1;
			if( *n > 26 ) *n = 26;
			return(t);
		}
	}
	*n = 0;
	return(s);
}

/*#$%
======================================================
	文字列の比較を行う
------------------------------------------------------
	t : 対象文字列
	s : 基準文字列
------------------------------------------------------
------------------------------------------------------
======================================================
*/
static int strcmpv(LPCSTR t, LPCSTR s)
{
	for( ; *s; s++, t++ ){
		if( *t != *s ) return(1);
	}
	return(0);
}

static	int		svf;		/* 完全一致フラグ	*/
/*#$%
================================================================
	プリフィックス検索用文字列比較
----------------------------------------------------------------
----------------------------------------------------------------
----------------------------------------------------------------
================================================================
*/
static int _strcmp(LPCSTR t, LPCSTR v)
{
/*	printf( "<%s>-<%s>\n", v, t );	*/
	for( ; *v; v++, t++ ){
		if( *v == '*' ){
			for( v++; *t && strcmpv(t, v); t++ );
			if( !*t ) return(1);
		}
		else if( *v == '\\' ){
			if( *t ) return(1);
		}
		else if( (*v!='?') && (*v != *t) ){
			return(1);
		}
	}
	if( svf && *t ) return(1);
	return(0);
}

/*#$%
======================================================
	コンストラクター
------------------------------------------------------
------------------------------------------------------
------------------------------------------------------
======================================================
*/
CCountry::CCountry()
{
	Init();
}

CCountry::~CCountry(void)
{
	Free();
}

/*#$%
======================================================
	ＤＸＣＣ定義領域を開放する
------------------------------------------------------
------------------------------------------------------
------------------------------------------------------
======================================================
*/
void CCountry::Init(void)
{
	cmax = 0;
	memset(ctl, 0, sizeof(ctl));
}

/*#$%
======================================================
	ＤＸＣＣ定義領域を開放する
------------------------------------------------------
------------------------------------------------------
------------------------------------------------------
======================================================
*/
void CCountry::Free(void)
{
	int i;
	CTL	*cp;

	for( cp = ctl, i = 0; i < cmax; i++, cp++ ){
		if( cp->Name != NULL ) delete cp->Name;
		if( cp->Code != NULL ) delete cp->Code;
		if( cp->QTH != NULL ) delete cp->QTH;
		if( cp->Cont != NULL ) delete cp->Cont;
		if( cp->TD != NULL ) delete cp->TD;
	}
	Init();
}


/*#$%
======================================================
	プリフィックスからカントリコードを得る
------------------------------------------------------
	p : プリフィックスのポインタ
------------------------------------------------------
	カントリコード
------------------------------------------------------
======================================================
*/
int CCountry::GetNo(LPCSTR s)
{
	LPSTR	p, pb, t, pp;
	int		i;
	int	j;

	if( !*s ) return(0);
	for( i = 0; i < cmax; i++ ){
		strcpy(wbf, ctl[i].Code);
		for( p = wbf; *p; ){
			p = StrDlm(pb, p, ',');
			if( (t = strchr(pb, '-')) != NULL ){
				*t = 0;
				t++;
				if( (*pb == *s) || (*pb != *t) ){
					for( pp = lcmpp(&j, pb, t); j; (*pp)++, j-- ){
						if( !_strcmp(s, pb) ) return(i+1);
					}
				}
			}
			else {
				if( !_strcmp(s, pb) ) return(i+1);
			}
		}
	}
	return(0);
}

/*#$%
======================================================
	コールサインからポインタを得る
------------------------------------------------------
	p : コールサインのポインタ
------------------------------------------------------
	ポインタ
------------------------------------------------------
======================================================
*/
int CCountry::GetNoP(LPCSTR p)
{
	int		n;

	svf = 1;
	if( (n = GetNo(p))!=0 ) return(n);
	svf = 0;
	if( (n = GetNo(p))!=0 ) return(n);
	return(0);
}
/*#$%
======================================================
	コールサインからポインタを得る
------------------------------------------------------
	p : コールサインのポインタ
------------------------------------------------------
	ポインタ
------------------------------------------------------
======================================================
*/
int CCountry::GetRefP(LPCSTR p)
{
	if( !cmax ) return 0;
	int		n;

	if( !(*p) ) return 0;
	if( ((n = GetNoP(p))!=0) && (ctl[n-1].Name != NULL) ){
		return n;
	}
	else {
		return 0;
	}
}
/*#$%
======================================================
	コールサインからカントリ名を得る
------------------------------------------------------
	p : コールサインのポインタ
------------------------------------------------------
	カントリ名のポインタ
------------------------------------------------------
======================================================
*/
LPCSTR CCountry::GetCountry(int n)
{
	if( n ){
		strcpy(wbf, ctl[n-1].Name);
		return(wbf);
	}
	else {
		return("?");
	}
}
/*#$%
======================================================
	コールサインから大陸名を得る
------------------------------------------------------
	p : コールサインのポインタ
------------------------------------------------------
	カントリ名のポインタ
------------------------------------------------------
======================================================
*/
LPCSTR CCountry::GetCont(int n)
{
	if( n ){
		strcpy(wbf, ctl[n-1].Cont);
		return(wbf);
	}
	else {
		return("?");
	}
}
/*#$%
======================================================
	コールサインからカントリ名を得る
------------------------------------------------------
	p : コールサインのポインタ
------------------------------------------------------
	カントリ名のポインタ
------------------------------------------------------
======================================================
*/
LPCSTR CCountry::GetCountry(LPCSTR p)
{
	if( !cmax ) return "";
	int		n;

	if( !(*p) ) return("?");
	if( ((n = GetNoP(p))!=0) && (ctl[n-1].Name != NULL) ){
		strcpy(wbf, ctl[n-1].Name);
		return(wbf);
	}
	else {
		return("?");
	}
}

/*#$%
======================================================
	コールサインから大陸名を得る
------------------------------------------------------
	p : コールサインのポインタ
------------------------------------------------------
	カントリ名のポインタ
------------------------------------------------------
======================================================
*/
LPCSTR CCountry::GetCont(LPCSTR p)
{
	if( !cmax ) return "";
	int		n;

	if( !(*p) ) return("?");
	if( ((n = GetNoP(p))!=0) && (ctl[n-1].Cont != NULL) ){
		strcpy(wbf, ctl[n-1].Cont);
		return(wbf);
	}
	else {
		return("?");
	}
}

/*#$%
======================================================
	ＤＸＣＣ定義ファイルを読み込む
------------------------------------------------------
	fm : ファイル名のポインタ
------------------------------------------------------
------------------------------------------------------
======================================================
*/
void CCountry::Load(LPCSTR fm)
{
	FILE	*fp;
	LPCSTR	p;
	char	hbf[512];

	Free();
	if( (fp = fopen(fm, "rt"))!=NULL ){
		while( !feof(fp) ){
			if( fgets(hbf, 512, fp)!=NULL ){
				if( hbf[0] == '$' ) break;
				ClipLF(hbf);
				_delchr(hbf, TAB);
				if( hbf[0] != '!' ){
					p = StrDlmCpy(wbf, hbf, ';', 512);
					clipsp(wbf);
					ctl[cmax].Name = StrDupe(wbf);
					if( p != NULL ){
						p = StrDlmCpy(wbf, p, ';', 512);
						clipsp(wbf);
						ctl[cmax].Code = StrDupe(wbf);
					}
					if( p != NULL ){
						p = StrDlmCpy(wbf, p, ';', 512);
						clipsp(wbf);
						ctl[cmax].QTH = StrDupe(wbf);
					}
					if( p != NULL ){
						p = StrDlmCpy(wbf, p, ';', 512);
						clipsp(wbf);
						ctl[cmax].Cont = StrDupe(wbf);
					}
					if( p != NULL ){
						StrDlmCpy(wbf, p, ';', 512);
						clipsp(wbf);
						ctl[cmax].TD = StrDupe(wbf);
					}
					cmax++;
					if( cmax >= CTMAX ) break;
				}
			}
		}
		fclose(fp);
	}
	else {
		WarningMB(MsgEng ? "'ARRL.DX' was not found.\r\n\r\nYou cannot use a re-creating DX entity function.\r\nThis is not a problem if you do not need it":"'ARRL.DX'が見つかりません.\r\n\r\nDXエンティティの再構築機能は使用できません.");
	}
}


